-- Сначала запустить init_mortal.sql
\ir init_mortal.sql

-- Запустить init_mortal.sql
\ir init_utils.sql


---- auth


create table session (
    id bigint generated always as identity primary key,
    revision revision,
    creation_date timestamp not null default current_timestamp
);
select setup_revision('session');

create table auth_state (
    session bigint references session on delete cascade on update cascade primary key,
    "user" bigint references users on delete cascade on update cascade
);


---- files


create table file (
    id bigint generated always as identity primary key,
    uri varchar(512) not null,
    upload_date timestamp not null default current_timestamp,
    expires_at timestamp,
    size_bytes bigint not null,
    owner_session bigint references session on update cascade,
    owner_user bigint references users on update cascade,
    owner_user_grave bigint references grave_users on update cascade
);
select setup_mortal_reference('file', 'owner_user');

create table bitmap (
    file bigint references file on delete cascade on update cascade primary key,
    width integer,
    height integer
);

create table image (
    file bigint references file on delete cascade on update cascade primary key,
    format varchar(8) not null,
    width integer,
    height integer
);

create table vector_image (
    file bigint references file on delete cascade on update cascade primary key,
    format varchar(8) not null,
    width real,
    height real
);

create table video (
    file bigint references file on delete cascade on update cascade primary key,
    format varchar(8) not null,
    duration_millis bigint,
    width integer,
    height integer
);


---- users


create table users (
    id bigint generated by default as identity primary key,
    revision revision,
    first_name varchar(64) not null,
    last_name varchar(64),
    registration_date timestamp not null default current_timestamp,
    phone_number varchar(32),
    email varchar(128),
    password_plaintext varchar(256),
    bio varchar(1024),
    birthday date,
    -- 4 is a first leap year. used as 'no year specified'
    check ( extract(year from birthday) > 1800 OR extract(year from birthday) = 4 ),

    cover bigint references file on update cascade,
    avatar bigint references file on update cascade
);
select setup_revision('users');

create table grave_users (
    id bigint primary key,
    deleted_at timestamp not null,
    first_name varchar(64) not null,
    last_name varchar(64)
);
select setup_mortal_table('users', 'id, first_name, last_name');


---- posts


create type post_content_type as enum ('standalone', 'repost');
create type scheduled_post_content_type as enum ('standalone', 'repost');

create table post (
    id bigint generated always as identity primary key,
    revision revision,
    created_at timestamp not null,
    author bigint references users on delete cascade on update cascade,
    reply_to bigint references post on update cascade,
    reply_to_grave bigint /* references grave_post on update cascade */,
    last_edit_date timestamp,
    content_type post_content_type not null
);

create table grave_post (
    id bigint primary key,
    created_at timestamp not null,
    last_edit_date timestamp,
    deleted_at timestamp not null,
    author user_id references users on update cascade,
    author_grave user_id references grave_users on update cascade
);

alter table post add foreign key (reply_to_grave) references grave_post on update cascade;
select setup_revision('post');
select setup_mortal_table('post', 'id, created_at, last_edit_date, author');
select setup_mortal_references('post', 'reply_to');
select setup_mortal_references('grave_post', 'author');


create or replace view view_post as (
    select
        p.id,
        p.revision,
        p.created_at,
        p.last_edit_date,
        p.content_type,
        -- author header
        a.id as author_id,
        a.first_name as author_first_name,
        a.last_name as author_last_name,
        -- reply header
        coalesce(r.id, gr.id) as reply_id,
        coalesce(r.created_at, gr.created_at) as reply_created_at,
        coalesce(null, gr.deleted_at) as reply_deleted_at,
        coalesce(r.author, gr.author, gr.author_grave) as reply_author_id,
        coalesce(ru.first_name, rgu.first_name) as reply_author_first_name,
        coalesce(ru.last_name, rgu.last_name) as reply_author_last_name,
        -- standalone
        standalone.text as standalone_text,
        -- repost
        repost.comment as repost_comment,
        coalesce(repost_p.id, repost_gp.id) as repost_original_id,
        coalesce(repost_p.created_at, repost_gp.created_at) as repost_original_created_at,
        coalesce(null, repost_gp.deleted_at) as repost_original_deleted_at,
        coalesce(repost_p.last_edit_date, repost_gp.last_edit_date) as repost_original_last_edit_date,
        coalesce(repost_u.id, repost_gpu.id, repost_gpgu.id) as repost_original_author_id,
        coalesce(repost_gu.deleted_at, repost_gpgu.deleted_at) as repost_original_author_deleted_at,
        coalesce(repost_u.first_name, repost_gpu.first_name, repost_gpgu.first_name) as repost_original_author_first_name,
        coalesce(repost_u.last_name, repost_gpu.last_name, repost_gpgu.last_name) as repost_original_author_last_name
    from post p

    -- author
    inner join users a on a.id = p.author
    -- reply header
    left join post r on r.id = p.reply_to
    left join grave_post gr on gr.id = p.reply_to_grave
    left join users ru on ru.id = r.author OR ru.id = gr.author
    left join grave_users rgu on rgu.id = gr.author_grave
    -- standalone
    left join post__standalone standalone on p.content_type = 'standalone' AND standalone.id = p.id
    -- repost
    left join post__repost repost on p.content_type = 'repost' AND repost.id = p.id
    left join post repost_p on repost_p.id = repost.original
    left join users repost_u on repost_u.id = repost_p.author
    left join grave_users repost_gu on repost_gu.id = repost_p.author
    left join grave_post repost_gp on repost_gp.id = repost.original_grave
    left join users repost_gpu on repost_gpu.id = repost_gp.author
    left join grave_users repost_gpgu on repost_gpgu.id = repost_gp.author_grave

    where (p.content_type = 'standalone' and standalone.text is not null)
       or (p.content_type = 'repost' and coalesce(repost.original, repost.original_grave) is not null)
);

drop view view_grave_post;
create or replace view view_grave_post as (
    select
        p.id,
        p.created_at,
        p.deleted_at,
        p.last_edit_date,
        -- author header
        a.id as author_id,
        a.first_name as author_first_name,
        a.last_name as author_last_name
    from grave_post p
    -- author
    inner join users a on a.id = p.author
);


create table post__standalone (
    id bigint references post on delete cascade on update cascade primary key,
    text varchar(4096) not null
);

create table post__standalone__attachments (
    id bigint generated always as identity,
    post bigint references post on delete cascade on update cascade,
    file bigint references file on update cascade,
    caption varchar(4096) not null
);

create table post__repost (
    id bigint references post on delete cascade on update cascade primary key,
    original bigint references post on update cascade,
    original_grave bigint references grave_post on update cascade,
    comment varchar(4096)
);
select setup_mortal_references('post__repost', 'original');

create table scheduled_post (
    id bigint generated always as identity primary key,
    author bigint not null references users on delete cascade on update cascade,
    date_to_publish timestamp not null,
    content_type post_content_type not null
);

create table scheduled_post__standalone (
    id bigint references scheduled_post on delete cascade on update cascade primary key,
    author bigint not null references users on delete cascade on update cascade,
    content_type post_content_type not null
);

create table scheduled_post__scheduled (
    id bigint references scheduled_post on delete cascade on update cascade primary key,
    author bigint not null references users on delete cascade on update cascade,
    original bigint references post on delete set null on update cascade,
    comment varchar(4096)
);
